<!DOCTYPE html>
<html lang="en" xml:lang="en">
<head>
    
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Simple SSL Proxy for Insecure Browser Content with Ruby or NGINX </title>
    <link rel="dns-prefetch" href="//maxcdn.bootstrapcdn.com">
    <link rel="dns-prefetch" href="//cdnjs.cloudflare.com">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="SSL protection is becoming de facto standard in web and mobile development. One potential problem is that website could be served via a secure SSL connection and still displayed as insecure by most of the modern browsers. It's enough that at least one of its resources is served without SSL. In this blog post, I will explain how to setup a simple Ruby and NGINX server to work as an SSL proxy for insecure content and describe some basic streaming techniques.">
    <meta name="robots" content="all">
    <meta name="author" content="Paweł Urbanek">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/styles.css?201802222159" type="text/css">

    
      <meta name="keywords" content="ssl proxy, heroku, cloudflare, cloudfront, aws, s3, insecure content, lets encrypt, ruby on rails, ruby, web development, mozilla">
    

    <link rel="canonical" href="https://pawelurbanek.com/2018/01/29/setup-ssl-proxy-for-insecure-browser-content-with-ruby-and-nginx/">
    <link rel="alternate" type="application/rss+xml" title="RSS Feed for Paweł Urbanek - Web and Mobile Developer, Full Stack Blog" href="/feed.xml" />


    <!-- Verifications -->
    

    <!-- Open Graph -->
    <!-- From: https://github.com/mmistakes/hpstr-jekyll-theme/blob/master/_includes/head.html -->
    <meta property="og:locale" content="en_US">
    <meta property="og:type" content="article">
    <meta property="og:title" content="Simple SSL Proxy for Insecure Browser Content with Ruby or NGINX ">
    <meta property="og:description" content="SSL protection is becoming de facto standard in web and mobile development. One potential problem is that website could be served via a secure SSL connection and still displayed as insecure by most of the modern browsers. It's enough that at least one of its resources is served without SSL. In this blog post, I will explain how to setup a simple Ruby and NGINX server to work as an SSL proxy for insecure content and describe some basic streaming techniques.">
    <meta property="og:url" content="https://pawelurbanek.com/2018/01/29/setup-ssl-proxy-for-insecure-browser-content-with-ruby-and-nginx/">
    <meta property="og:site_name" content="Paweł Urbanek - Web and Mobile Developer, Full Stack Blog">
    
    <meta property="og:image" content="https://pawelurbanek.com/assets/ssl-certificate-lock-3d84ed9f9cc18d8f0384e029142efe93e15d39ac08ae08e69d063573510c21c1.jpg">
    


    <!-- Twitter Card -->
    
      <meta name="twitter:card" content="summary_large_image">
      <meta property="og:image:width" content="800">
      <meta property="og:image:height" content="500">
      <meta property="article:published_time" content="2018-01-29T10:10:00+01:00" />
    

    
    <meta name="twitter:image" content="https://pawelurbanek.com/assets/ssl-certificate-lock-3d84ed9f9cc18d8f0384e029142efe93e15d39ac08ae08e69d063573510c21c1.jpg">
    

    <meta name="twitter:site" content="@_pawurb" />
    <meta name="twitter:creator" content="@_pawurb" />

    <meta name="twitter:title" content="Simple SSL Proxy for Insecure Browser Content with Ruby or NGINX" />
    <meta name="twitter:description" content="SSL protection is becoming de facto standard in web and mobile development. One potential problem is that website could be served via a secure SSL connection and still displayed as insecure by most of the modern browsers. It's enough that at least one of its resources is served without SSL. In this blog post, I will explain how to setup a simple Ruby and NGINX server to work as an SSL proxy for insecure content and describe some basic streaming techniques." />
    <meta name="twitter:url" content="https://pawelurbanek.com/2018/01/29/setup-ssl-proxy-for-insecure-browser-content-with-ruby-and-nginx/" />

    <!-- Icons -->
    <link rel="apple-touch-icon" sizes="57x57" href="/apple-touch-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/apple-touch-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/apple-touch-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="60x60" href="/apple-touch-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/apple-touch-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/apple-touch-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/apple-touch-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon-180x180.png">
    <link rel="icon" type="image/png" href="/favicon-192x192.png" sizes="192x192">
    <link rel="icon" type="image/png" href="/favicon-160x160.png" sizes="160x160">
    <link rel="icon" type="image/png" href="/favicon-96x96.png" sizes="96x96">
    <link rel="icon" type="image/png" href="/favicon-16x16.png" sizes="16x16">
    <link rel="icon" type="image/png" href="/favicon-32x32.png" sizes="32x32">


    
    <script type="text/javascript">
       (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
       (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
       m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
       })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
       ga('create', 'UA-34244867-12', 'auto');
       ga('send', 'pageview');
    </script>
    

    
<!-- Google Structured Data -->
  <script type="application/ld+json">
  {
    "@context": "http://schema.org",
    "@type": "BlogPosting",
    "mainEntityOfPage": {
      "@type":"WebPage",
      "@id":"https://pawelurbanek.com/2018/01/29/setup-ssl-proxy-for-insecure-browser-content-with-ruby-and-nginx/"
    },
    "headline": "Simple SSL Proxy for Insecure Browser Content with Ruby or NGINX",
    "image": {
      "@type": "ImageObject",
      "url": "https://pawelurbanek.com/assets/ssl-certificate-lock-3d84ed9f9cc18d8f0384e029142efe93e15d39ac08ae08e69d063573510c21c1.jpg",
      "height": 500,
      "width": 800
    },
    "datePublished": "2018-01-29",
    "dateModified": "2018-02-01",
    "author": {
      "@type": "Person",
      "name": "Paweł Urbanek"
    },
    "publisher": {
      "@type": "Organization",
      "name": "PabloWeb Paweł Urbanek",
      "logo": {
        "@type": "ImageObject",
        "url": "https://pawelurbanek.com/assets/pabloweb-69223ab6871fe2232fabdd00e23d420a15170da8a9644aee5f73a422067629c4.jpg",
        "width": 600,
        "height": 60
      }
    },
    "description": "SSL protection is becoming de facto standard in web and mobile development. One potential problem is that website could be served via a secure SSL connection and still displayed as insecure by most of the modern browsers. It's enough that at least one of its resources is served without SSL. In this blog post, I will explain how to setup a simple Ruby and NGINX server to work as an SSL proxy for insecure content and describe some basic streaming techniques.",
    "keywords": "ssl proxy, heroku, cloudflare, cloudfront, aws, s3, insecure content, lets encrypt, ruby on rails, ruby, web development, mozilla"
  }
  </script>


</head>

<body class="site">
  

  <div class="site-wrap">
    <header class="site-header px2 px-responsive">
  <div class="mt2 wrap">
    <div class="measure">
      <div class='site-title'>
        <h1 class='author-name'>
          <a class='main-title' href="https://pawelurbanek.com">Paweł Urbanek</a>
        </h1>
        <br>
        <h2 class='blog-title'>
          <a href="https://pawelurbanek.com" class='subtitle'>Full Stack Blog</a>
        </h2>
      </div>
      <nav class="site-nav">
        




    

    
        <a class='theme-color' href="/">Home</a>
    




    

    
        <a class='theme-color' href="/about">About</a>
    




    

    
        <a class='theme-color' href="/contact">Contact</a>
    




        
          <div class="social-icons">
  <div class="social-icons-right">
    
      <a class="fa fa-github" href="https://github.com/pawurb" target="_blank"></a>
    
    
      <a class="fa fa-twitter" href="https://twitter.com/_pawurb" target="_blank"></a>
    
  </div>
  <div class="right">
    
  </div>
</div>
<div class="clearfix"></div>

        
      </nav>
      <div class="clearfix"></div>
    </div>
  </div>
</header>


    <div class="post p2 p-responsive wrap" role="main">
      <div class="measure">
        



  
    <link rel="amphtml" href="https://pawelurbanek.com/amp/2018/01/29/setup-ssl-proxy-for-insecure-browser-content-with-ruby-and-nginx">
  


<div class="post-header mb2">
  <h1>Simple SSL Proxy for Insecure Browser Content with Ruby or NGINX</h1>
  <span class="post-meta theme-color">Jan 29, 2018</span><br>
  
  <span class="post-meta small">
  
    5 minute read
  
  </span>
</div>

<article class="post-content">
  <p><img class="center-image post-main-image" alt="Lock represents a secure SSL certificate" src="/assets/ssl-certificate-lock-3d84ed9f9cc18d8f0384e029142efe93e15d39ac08ae08e69d063573510c21c1.jpg" /></p>

<p>SSL protection is becoming de facto standard in web and mobile development. One potential problem is that website could be served via a secure SSL connection and still displayed as insecure by most of the modern browsers. It’s enough that at least one of its resources is served without SSL. In this blog post, I will explain how to setup Ruby and NGINX server to work as an SSL proxy for insecure content and describe some basic streaming techniques.</p>

<p><img class="center-image" alt="Insecure browser content warning in URL bar" src="/assets/insecure-browser-content-alert1-46d14256a8c9b097e9c261ce2fa4ebcdef811f48eb141a70603f987878190363.png" /></p>

<p><img class="center-image" alt="Insecure browser content warning in developer console" src="/assets/insecure-browser-content-alert2-27444ef96123d6f54b6eaf32658296e8277af1eb161b1c3dc5a036f74c6ec011.png" />
<span class="annotation">Developer console and URL bar display insecure content warnings on <a class="link-grey" href="https://wishlist.apki.io" target="_blank"> https://wishlist.apki.io</a>.</span></p>

<p>Until recently iTunes Store pages were displayed as insecure in the browsers because of <code class="highlighter-rouge">http</code> image assets. At the time of writing this blog post, iTunes API does not officially<sup id="fnref:1"><a href="#fn:1" class="footnote">1</a></sup> provide image assets via SSL.</p>

<p>You can check yourself:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="nb">require</span> <span class="s2">"open-uri"</span>
<span class="nb">require</span> <span class="s2">"json"</span>

<span class="no">JSON</span><span class="p">.</span><span class="nf">parse</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="s2">"https://itunes.apple.com/lookup?id=1201642309"</span><span class="p">).</span><span class="nf">read</span><span class="p">)[</span><span class="s2">"results"</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s2">"screenshotUrls"</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

<span class="o">=&gt;</span> <span class="s2">"http://is4.mzstatic.com/image/thumb/Purple128/v4/50/b6/59/50b65977-5605-4cf3-eee6-6ff350a9c9c4/source/406x228bb.jpg"</span></code></pre></figure>

<p>If you want to display this kind of insecure asset<sup id="fnref:2"><a href="#fn:2" class="footnote">2</a></sup> on your webpage without browser warnings, here’s what you can do:</p>

<h2 id="download-assets-and-serve-them-via-amazon-s3">Download assets and serve them via Amazon S3</h2>

<p>You could download all the required assets to deliver them via a secure connection. In this case <a href="https://aws.amazon.com/s3/" target="_blank">Amazon S3</a> with <a href="https://aws.amazon.com/cloudfront/" target="_blank">CloudFront</a> could serve you well. An advantage of this approach is that traffic does not go through your servers, and assets can be cached using CloudFront CDN. Unfortunately, you have to take care of updating assets yourself (app icons could change at any time), and pay for all the bandwidth.</p>

<h2 id="down-gem-for-streaming-support">“down” gem for streaming support</h2>

<p>Each of the following examples uses <a href="https://github.com/janko-m/down" target="_blank">down gem</a>. It provides a simple API for working with file downloads and supports more advanced techniques like streaming and caching. It also has a small memory footprint of less the <code class="highlighter-rouge">0.4 MB</code> on load.</p>

<h2 id="use-rails-app-as-an-ssl-proxy">Use Rails app as an SSL proxy</h2>

<p>Another solution would be to proxy an asset request through a Rails-based server. In that case, a Rails app downloads an asset and sends it to the browser via a secure connection. You would need to include an asset location as a parameter of the request. Here’s how a simple Rails controller implementation could look like:</p>

<p><code class="highlighter-rouge">app/config/routes.rb</code></p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby">  <span class="n">get</span> <span class="s2">"/"</span><span class="p">,</span> <span class="ss">to: </span><span class="s2">"files#show"</span></code></pre></figure>

<p><code class="highlighter-rouge">app/controllers/files_controller.rb</code></p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="nb">require</span> <span class="s2">"down"</span>

<span class="k">class</span> <span class="nc">FilesController</span> <span class="o">&lt;</span> <span class="no">ApplicationController</span>
  <span class="k">def</span> <span class="nf">show</span>
    <span class="n">data_source</span> <span class="o">=</span> <span class="no">Down</span><span class="p">.</span><span class="nf">download</span><span class="p">(</span><span class="n">params</span><span class="p">.</span><span class="nf">fetch</span><span class="p">(</span><span class="ss">:target</span><span class="p">))</span>
    <span class="n">send_data</span> <span class="n">data_source</span><span class="p">.</span><span class="nf">read</span><span class="p">,</span> <span class="ss">type: </span><span class="n">data_source</span><span class="p">.</span><span class="nf">content_type</span><span class="p">,</span> <span class="ss">disposition: </span><span class="s2">"inline"</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre></figure>

<p>Then you could access the asset using the following URL:</p>

<p><code class="highlighter-rouge">https://yourapp.com?target=http://is4.mzstatic.com/image/thumb/Purple128/v4/50/b6/59/50b65977-5605-4cf3-eee6-6ff350a9c9c4/source/406x228bb.jpg</code></p>

<h3 id="streaming-for-large-assets">Streaming for large assets</h3>

<p>When dealing with a larger asset a better idea would be to stream it to client part by part. To do it you need to assign an object responding to <code class="highlighter-rouge">each</code> method to <code class="highlighter-rouge">response_body</code> controller property:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="nb">require</span> <span class="s2">"down"</span>

<span class="k">class</span> <span class="nc">FilesController</span> <span class="o">&lt;</span> <span class="no">ApplicationController</span>
  <span class="no">CHUNK_SIZE</span> <span class="o">=</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">128</span> <span class="c1"># 128 KB</span>

  <span class="k">def</span> <span class="nf">show</span>
    <span class="n">data_source</span> <span class="o">=</span> <span class="no">Down</span><span class="p">.</span><span class="nf">open</span><span class="p">(</span><span class="n">params</span><span class="p">.</span><span class="nf">fetch</span><span class="p">(</span><span class="ss">:target</span><span class="p">))</span>
    <span class="nb">self</span><span class="p">.</span><span class="nf">content_type</span> <span class="o">=</span> <span class="n">data_source</span><span class="p">.</span><span class="nf">data</span><span class="p">.</span><span class="nf">fetch</span><span class="p">(</span><span class="ss">:headers</span><span class="p">).</span><span class="nf">fetch</span><span class="p">(</span><span class="s2">"Content-Type"</span><span class="p">)</span>
    <span class="nb">self</span><span class="p">.</span><span class="nf">response_body</span> <span class="o">=</span> <span class="no">Enumerator</span><span class="p">.</span><span class="nf">new</span> <span class="k">do</span> <span class="o">|</span><span class="n">body</span><span class="o">|</span>
      <span class="k">while</span> <span class="n">data_source</span><span class="p">.</span><span class="nf">eof?</span> <span class="o">==</span> <span class="kp">false</span>
        <span class="n">body</span> <span class="o">&lt;&lt;</span> <span class="n">data_source</span><span class="p">.</span><span class="nf">read</span><span class="p">(</span><span class="no">CHUNK_SIZE</span><span class="p">)</span>
      <span class="k">end</span>
      <span class="n">data_source</span><span class="p">.</span><span class="nf">close</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre></figure>

<p>An advantage of this approach is that in case of large assets, they would not need to be instantiated into memory all at once. It’s an equivalent of using <code class="highlighter-rouge">File.readlines</code> instead of <code class="highlighter-rouge">File.read</code> when working with files. Depending on your use case you could play around with <code class="highlighter-rouge">CHUNK_SIZE</code> constant value.</p>

<p>You can also check out my other blog post for more tips on how to <a href="https://pawelurbanek.com/2018/01/15/limit-rails-memory-usage-fix-R14-and-save-money-on-heroku/">reduce memory usage in Rails apps</a>.</p>

<h2 id="use-ruby-rack-app-as-an-ssl-proxy">Use Ruby Rack app as an SSL proxy</h2>

<p>You could improve performance by dropping Rails altogether and using a barebones Rack app to serve the asset. Here’s a basic Rack server implementation:</p>

<p><code class="highlighter-rouge">config.ru</code></p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="nb">require</span> <span class="s2">"down"</span>

<span class="n">run</span> <span class="no">Proc</span><span class="p">.</span><span class="nf">new</span> <span class="p">{</span> <span class="o">|</span><span class="n">env</span><span class="o">|</span>
  <span class="n">req</span> <span class="o">=</span> <span class="no">Rack</span><span class="o">::</span><span class="no">Request</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">env</span><span class="p">)</span>
  <span class="n">data_source</span> <span class="o">=</span> <span class="no">Down</span><span class="p">.</span><span class="nf">download</span><span class="p">(</span><span class="n">req</span><span class="p">.</span><span class="nf">params</span><span class="p">.</span><span class="nf">fetch</span><span class="p">(</span><span class="s2">"target"</span><span class="p">))</span>
  <span class="p">[</span>
    <span class="mi">200</span><span class="p">,</span>
     <span class="p">{</span>
       <span class="s2">"Content-Type"</span> <span class="o">=&gt;</span> <span class="n">data_source</span><span class="p">.</span><span class="nf">content_type</span><span class="p">,</span>
       <span class="s2">"Content-Length"</span> <span class="o">=&gt;</span> <span class="n">data_source</span><span class="p">.</span><span class="nf">size</span><span class="p">,</span>
     <span class="p">},</span>
     <span class="p">[</span><span class="n">data_source</span><span class="p">.</span><span class="nf">read</span><span class="p">]</span>
  <span class="p">]</span>
<span class="p">}</span></code></pre></figure>

<p><span class="annotation">You can run Rack apps with a <i>rackup</i> command</span></p>

<h3 id="assets-streaming-with-rack">Assets streaming with Rack</h3>

<p>Here is how you could send an asset part by part using <code class="highlighter-rouge">Rack::Chunked</code> middleware:</p>

<p><code class="highlighter-rouge">config.ru</code></p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="nb">require</span> <span class="s2">"down"</span>

<span class="k">class</span> <span class="nc">App</span>
  <span class="no">CHUNK_SIZE</span> <span class="o">=</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">128</span> <span class="c1"># 128 KB</span>

  <span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="n">env</span><span class="p">)</span>
    <span class="n">req</span> <span class="o">=</span> <span class="no">Rack</span><span class="o">::</span><span class="no">Request</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">env</span><span class="p">)</span>
    <span class="vi">@data_source</span> <span class="o">=</span> <span class="no">Down</span><span class="p">.</span><span class="nf">open</span><span class="p">(</span><span class="n">req</span><span class="p">.</span><span class="nf">params</span><span class="p">.</span><span class="nf">fetch</span><span class="p">(</span><span class="s2">"target"</span><span class="p">))</span>
    <span class="n">headers</span> <span class="o">=</span> <span class="vi">@data_source</span><span class="p">.</span><span class="nf">data</span><span class="p">.</span><span class="nf">fetch</span><span class="p">(</span><span class="ss">:headers</span><span class="p">)</span>
    <span class="p">[</span>
      <span class="mi">200</span><span class="p">,</span>
      <span class="p">{</span>
        <span class="s2">"Content-Type"</span> <span class="o">=&gt;</span> <span class="n">headers</span><span class="p">.</span><span class="nf">fetch</span><span class="p">(</span><span class="s2">"Content-Type"</span><span class="p">),</span>
        <span class="s2">"Content-Encoding"</span> <span class="o">=&gt;</span> <span class="s2">"Chunked"</span>
      <span class="p">},</span>
      <span class="nb">self</span>
    <span class="p">]</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">each</span>
    <span class="k">while</span> <span class="vi">@data_source</span><span class="p">.</span><span class="nf">eof?</span> <span class="o">==</span> <span class="kp">false</span>
      <span class="k">yield</span> <span class="vi">@data_source</span><span class="p">.</span><span class="nf">read</span><span class="p">(</span><span class="no">CHUNK_SIZE</span><span class="p">)</span>
    <span class="k">end</span>
    <span class="vi">@data_source</span><span class="p">.</span><span class="nf">close</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">use</span> <span class="no">Rack</span><span class="o">::</span><span class="no">Chunked</span>
<span class="n">run</span> <span class="no">App</span><span class="p">.</span><span class="nf">new</span></code></pre></figure>

<h2 id="use-nginx-as-an-ssl-proxy">Use NGINX as an SSL proxy</h2>

<p>A different solution would be using an NGINX to proxy pass to an insecure assets. You can check out my <a href="/2018/01/22/setup-multiple-domains-with-free-ssl-from-cloudflare/">previous blog post</a> for tips on how to configure NGINX with free SSL. If you are using Heroku as your hosting provider, you can setup NGINX as a reverse proxy in front of your Rails app using <a href="https://github.com/KazW/nginx-buildpack" target="_blank">a buildpack</a>.</p>

<p>Here’s a sample config:</p>

<figure class="highlight"><pre><code class="language-nginx" data-lang="nginx"><span class="k">server</span> <span class="p">{</span>
     <span class="kn">listen</span> <span class="mi">80</span><span class="p">;</span>
     <span class="kn">listen</span> <span class="mi">443</span><span class="p">;</span>
     <span class="kn">server_name</span> <span class="s">example-proxy.com</span><span class="p">;</span>

     <span class="kn">ssl</span>        <span class="no">on</span><span class="p">;</span>
     <span class="kn">ssl_certificate</span>         <span class="n">/etc/nginx/origin_cert.pem</span><span class="p">;</span>
     <span class="kn">ssl_certificate_key</span>     <span class="n">/etc/nginx/private_key.pem</span><span class="p">;</span>

     <span class="kn">location</span> <span class="n">/</span> <span class="p">{</span>
        <span class="kn">resolver</span> <span class="mi">8</span><span class="s">.8.8.8</span><span class="p">;</span>
        <span class="kn">proxy_pass</span> <span class="nv">$arg_target</span><span class="p">;</span>
     <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p><code class="highlighter-rouge">resolver 8.8.8.8;</code> line is needed to dynamically resolve DNS config of a target asset server and enable support for different assets hosts. An advantage of this solution is that you don’t block your Ruby process and NGINX is better suited to handle multiple concurrent clients than Ruby servers.</p>

<h2 id="summary">Summary</h2>

<p>I’ve been using the NGINX based solution in <a href="https://wishlist.apki.io/" target="_blank">Smart Wishlist</a> for quite a while now to serve iTunes assets via SSL to both React based frontend and iOS apps. Remember that if your project has a lot of traffic, you would need to watch out for problems with rate limiting by your assets API provider. You could also use these techniques to proxy pass any other kind of static assets, not only images.</p>

<p>Hope those tips can help you offload some of the work from your servers. Doing an SSL proxy pass is quicker and cheaper to implement than downloading the assets and hosting them yourself.</p>

<p><strong>Disclaimer:</strong> As pointed out in the comments, these examples do not include any restrictions on how and which assets can be accessed. In theory bad guys could start piggybacking on a proxy configured like this. You should consider IP, host or asset type based whitelist to make it more secure.</p>

<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p>iTunes API assets are available through SSL via an undocumented URL: <code class="highlighter-rouge">http://is4-ssl.mzstatic.com/image/thumb/Purple128/v4/50/b6/59/50b65977-5605-4cf3-eee6-6ff350a9c9c4/source/406x228bb.jpg</code> but it could change at any time. Hopefully, Apple will migrate all of iTunes API to SSL only soon. Point of this blog post is to show what you could do if SSL version of the asset was not available at all. <a href="#fnref:1" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:2">
      <p>A screenshot comes for an <a href="https://itunes.apple.com/us/app/playdeads-inside/id1201642309?mt=8" target="_blank">INSIDE</a> game. <a href="#fnref:2" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
</div>

</article>


  <div class="share-page">
  <div class="share-links">
    
      <a class="fa fa-twitter" href="https://twitter.com/intent/tweet?text=Simple+SSL+Proxy+for+Insecure+Browser+Content+with+Ruby+or+NGINX&amp;url=https%3A%2F%2Fpawelurbanek.com%2F2018%2F01%2F29%2Fsetup-ssl-proxy-for-insecure-browser-content-with-ruby-and-nginx%2F" rel="nofollow" target="_blank" title="Share on Twitter"></a>
    
    
      <a class="fa fa-facebook" href="https://facebook.com/sharer.php?u=https%3A%2F%2Fpawelurbanek.com%2F2018%2F01%2F29%2Fsetup-ssl-proxy-for-insecure-browser-content-with-ruby-and-nginx%2F" rel="nofollow" target="_blank" title="Share on Facebook"></a>
    
  </div>
</div>




  <div class="page-navigation">
  
    <a class="prev navigation-link" href="/2018/01/22/setup-multiple-domains-with-free-ssl-from-cloudflare/">&laquo; Multiple Domains with Free Wildcard SSL from Cloudflare</a>

  
  
    <a class="right next navigation-link" href="/2018/02/05/optimize-rails-performance-bottleneck-with-caching-and-rack-middleware/"> Optimize Rails Performance with Redis Caching and Rack Middleware &raquo;</a>
  
</div>

<div class="post-footer">
  <p>
    Posted by Paweł Urbanek on Jan 29, 2018
    <br>
    Find me on <a class='link' target='_blank' href="https://twitter.com/_pawurb">Twitter</a> or <a class='link' target='_blank' href="https://github.com/pawurb">GitHub</a>.
  </p>
</div>

<div class='center'>
  <p>Subscribe if you want to be notified about new blog posts. I promise no spam.</p>
    <div id="mc_embed_signup">
  <form action="https://pawelurbanek.us17.list-manage.com/subscribe/post?u=185903fd35e2bd56525298439&amp;id=d8064f77fc" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="validate" target="_blank" novalidate>
      <div id="mc_embed_signup_scroll">

  <div class="mc-field-group">
    <input type="email" value="" name="EMAIL" class="required email input-form" placeholder='Email' id="mce-EMAIL">
  </div>
    <div id="mce-responses" class="clear">
      <div class="response" id="mce-error-response" style="display:none"></div>
      <div class="response" id="mce-success-response" style="display:none"></div>
    </div>    <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->
      <div style="position: absolute; left: -5000px;" aria-hidden="true"><input type="text" name="b_185903fd35e2bd56525298439_d8064f77fc" tabindex="-1" value=""></div>
      <div class="clear"><input type="submit" value="Subscribe" name="subscribe" id="mc-embedded-subscribe" class="button"></div>
      </div>
  </form>
  </div>

</div>




  <div id="disqus_thread"></div>
  <script type="text/javascript">
    var disqus_shortname  = 'pawelurbanek';
    var disqus_identifier = '/2018/01/29/setup-ssl-proxy-for-insecure-browser-content-with-ruby-and-nginx';
    var disqus_title      = "Simple SSL Proxy for Insecure Browser Content with Ruby or NGINX";

    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>




      </div>
    </div>
  </div>

  <footer class="center">
  <div class="measure">
    <small>
      © Paweł Urbanek 2018
    </small>
  </div>
</footer>


  
<!-- Fonts -->

<link href='//fonts.googleapis.com/css?family=Merriweather:900,900italic,300,300italic' rel='stylesheet' type='text/css'>
<link href='//fonts.googleapis.com/css?family=Lato:900,300' rel='stylesheet' type='text/css'>



  <link href="//maxcdn.bootstrapcdn.com/font-awesome/latest/css/font-awesome.min.css" rel="stylesheet">


</body>
</html>
